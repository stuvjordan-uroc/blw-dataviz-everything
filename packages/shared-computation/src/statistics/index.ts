import { type Split, type ResponseGroup, type RespondentData, type Question, ResponseQuestion, GroupingQuestion } from "../types";
import { getQuestionKey, createResponseMap } from '../utils';

export type StatsConfig = {
  responseQuestions: ResponseQuestion[],
  groupingQuestions: GroupingQuestion[]
}

/**
 * Callback function type for statistics subscribers.
 * Called whenever the statistics are updated with new data.
 */
export type StatisticsSubscriber = (updateResult: StatisticsUpdateResult) => void;

/**
 * Subscription handle that allows unsubscribing.
 */
export interface StatisticsSubscription {
  /** Unsubscribe from updates */
  unsubscribe: () => void;
}

/**
 * Represents a change to a specific response group.
 */
export interface ResponseGroupChange {
  /** Label identifying the response group */
  responseGroupLabel: string;
  /** Count before the update */
  countBefore: number;
  /** Count after the update */
  countAfter: number;
  /** Weight before the update */
  weightBefore: number;
  /** Weight after the update */
  weightAfter: number;
  /** Proportion before the update */
  proportionBefore: number;
  /** Proportion after the update */
  proportionAfter: number;
}

/**
 * Represents changes to a response question within a split.
 */
export interface ResponseQuestionChange {
  /** Question key generated by getQuestionKey */
  responseQuestionKey: string;
  /** Total weight before the update */
  totalWeightBefore: number;
  /** Total weight after the update */
  totalWeightAfter: number;
  /** Total count before the update */
  totalCountBefore: number;
  /** Total count after the update */
  totalCountAfter: number;
  /** Changes to expanded response groups */
  expandedGroupChanges: ResponseGroupChange[];
  /** Changes to collapsed response groups */
  collapsedGroupChanges: ResponseGroupChange[];
}

/**
 * Represents all changes to a single split.
 */
export interface SplitDelta {
  /** Index of the split in the splits array */
  splitIndex: number;
  /** Changes to response questions in this split */
  responseQuestionChanges: ResponseQuestionChange[];
}

/**
 * Result returned by updateSplits method.
 * Contains processing metadata and deltas for incremental updates.
 */
export interface StatisticsUpdateResult {
  /** Number of valid respondents included in this update */
  validCount: number;
  /** Number of invalid respondents excluded from this update */
  invalidCount: number;
  /** Total number of respondents processed in this update */
  totalProcessed: number;
  /** Array of splits that changed, with details of all changes */
  deltas: SplitDelta[];
}

/**
 * Result returned by static computeStatistics method.
 * Contains computed splits and processing metadata.
 */
export interface StatisticsResult {
  /** Array of splits with computed statistics */
  splits: Split[];
  /** Number of valid respondents included in statistics */
  validCount: number;
  /** Number of invalid respondents excluded from statistics */
  invalidCount: number;
  /** Total number of respondents processed (valid + invalid) */
  totalProcessed: number;
}

/**
 * Statistics class for computing poll statistics from session configuration and response data.
 * 
 * This class processes respondent data to compute statistics for poll questions, organizing
 * results into "splits" based on grouping questions. Each split represents a subset of respondents
 * filtered by their answers to grouping questions, with computed proportions for response questions.
 * 
 * ## Features
 * 
 * - **Flexible initialization**: Create an empty instance (all statistics at 0) or initialize with data
 * - **Incremental updates**: Add new respondent data as it arrives using `updateSplits()`
 * - **Automatic validation**: Invalid respondents are filtered out and tracked separately
 * - **Weighting support**: Optional weight question for weighted statistics
 * - **Progress tracking**: Track counts of valid, invalid, and total respondents processed
 * 
 * ## Usage
 * 
 * ```typescript
 * // Create empty instance
 * const stats = new Statistics(StatsConfig);
 * 
 * // Or initialize with data
 * const stats = new Statistics(StatsConfig, initialRespondents, weightQuestion);
 * 
 * // Update with new data as it arrives
 * stats.updateSplits(newBatch);
 * 
 * // Access results
 * const splits = stats.getSplits();
 * const validCount = stats.getValidRespondentsCount();
 * ```
 * 
 * ## Validation
 * 
 * Respondents are validated before being included in statistics. A respondent is valid only if:
 * 1. Has answered ALL grouping questions with values in their respective response groups
 * 2. If weightQuestion is defined, has answered it with a non-null numeric value
 * 3. Has answered at least one response question with a value in an expanded response group
 * 
 * Invalid respondents are counted but excluded from statistics.
 * 
 * ## Error Handling
 * 
 * **Throws Error** if corrupted weight data is detected (weight <= 0) during processing.
 * This indicates a data integrity issue that should be resolved by validating/cleaning
 * weight data before it reaches this class.
 * 
 * ## Thread Safety
 * 
 * **This class is NOT thread-safe.** Do not call `updateSplits()` concurrently from multiple
 * async contexts. Each `updateSplits()` call should complete before the next one begins.
 * The methods are synchronous and safe in single-threaded JavaScript environments, but
 * concurrent calls could lead to race conditions and corrupted statistics.
 * 
 * @example
 * ```typescript
 * // Typical usage for a live poll
 * const stats = new Statistics(StatsConfig, [], weightQuestion);
 * 
 * // As data streams in...
 * pollStream.on('data', (batch) => {
 *   try {
 *     stats.updateSplits(batch);
 *     console.log(`Processed ${stats.getTotalRespondentsProcessed()} respondents`);
 *     console.log(`Valid: ${stats.getValidRespondentsCount()}, Invalid: ${stats.getInvalidRespondentsCount()}`);
 *   } catch (error) {
 *     console.error('Corrupted weight data detected:', error);
 *   }
 * });
 * ```
 */
export class Statistics {
  private readonly statsConfig: StatsConfig;
  private readonly splits: Split[];
  private readonly weightQuestion?: Question;
  private validRespondentsCount: number = 0;
  private invalidRespondentsCount: number = 0;

  // Subscription management
  private subscribers: Set<StatisticsSubscriber> = new Set();
  private nextSubscriberId = 0;
  private subscriberIds: Map<StatisticsSubscriber, number> = new Map();

  /**
   * Create a new Statistics instance.
   * 
   * @param StatsConfig - The session configuration defining response and grouping questions
   * @param respondentsData - Optional array of respondent data to compute statistics from
   * @param weightQuestion - Optional question to use for weighting respondents
   */
  constructor(statsConfig: StatsConfig, respondentsData?: RespondentData[], weightQuestion?: Question) {
    this.statsConfig = statsConfig;
    this.splits = this.initializeSplits(statsConfig);
    if (weightQuestion) {
      this.weightQuestion = weightQuestion;
    }

    // If respondent data was provided, process it to populate statistics
    if (respondentsData && respondentsData.length > 0) {
      // Process each respondent's data
      for (const respondentData of respondentsData) {
        // Transform the respondent data into a map for efficient lookup
        const responseMap = createResponseMap(respondentData);

        // Validate that this respondent's data meets all requirements
        const isValid = this.validateRespondentData(responseMap);

        // Only update statistics if the respondent data is valid
        if (isValid) {
          this.updateFromSingleRespondent(responseMap);
          this.validRespondentsCount++;
        } else {
          // Track invalid respondents
          this.invalidRespondentsCount++;
        }
      }
    }
  }

  /**
   * Compute statistics from respondent data without creating a persistent instance.
   * 
   * This static method is ideal for scenarios where you don't need to maintain state in memory:
   * - **Batch processing**: Compute statistics once from a complete dataset
   * - **External storage**: Load splits from database, update with new data, save back
   * - **Stateless services**: Process requests without maintaining instance state
   * 
   * The method can either compute statistics from scratch or update existing splits that
   * were previously computed and stored externally (e.g., in a database or on disk).
   * 
   * @param statsConfig - The session configuration defining response and grouping questions
   * @param respondentsData - Array of respondent data to process
   * @param weightQuestion - Optional question to use for weighting respondents
   * @param existingSplits - Optional pre-existing splits to update (if omitted, starts from scratch)
   * @returns Object containing computed splits and processing statistics
   * @throws Error if weight data is corrupted (weight <= 0)
   * 
   * @example
   * ```typescript
   * // Compute from scratch (batch processing)
   * const result = Statistics.computeStatistics(
   *   StatsConfig,
   *   allRespondents,
   *   weightQuestion
   * );
   * console.log(`Processed ${result.totalProcessed} respondents`);
   * console.log(`Valid: ${result.validCount}, Invalid: ${result.invalidCount}`);
   * ```
   * 
   * @example
   * ```typescript
   * // Update existing splits from database
   * const existingSplits = await loadSplitsFromDB(sessionId);
   * const result = Statistics.computeStatistics(
   *   StatsConfig,
   *   newRespondents,
   *   weightQuestion,
   *   existingSplits
   * );
   * await saveSplitsToDB(sessionId, result.splits);
   * ```
   */
  static computeStatistics(
    statsConfig: StatsConfig,
    respondentsData: RespondentData[],
    weightQuestion?: Question,
    existingSplits?: Split[]
  ): StatisticsResult {
    // Create a temporary instance for computation
    // If existingSplits provided, start with empty data (we'll replace splits below)
    // Otherwise, let constructor initialize splits from scratch
    const temp = new Statistics(
      statsConfig,
      existingSplits ? [] : [],
      weightQuestion
    );

    // If existing splits were provided, replace the initialized splits
    // This allows updating splits that were previously computed and stored
    if (existingSplits) {
      // Replace the contents of the splits array while maintaining the reference
      const splitsArray = temp['splits'] as Split[];
      splitsArray.splice(0, splitsArray.length, ...existingSplits);
    }

    // Process the respondent data
    // This will update the splits and increment the counters
    if (respondentsData.length > 0) {
      temp.updateSplits(respondentsData);
    }

    // Extract results and return
    // The temporary instance will be garbage collected after this
    return {
      splits: temp.getSplits(),
      validCount: temp.getValidRespondentsCount(),
      invalidCount: temp.getInvalidRespondentsCount(),
      totalProcessed: temp.getTotalRespondentsProcessed()
    };
  }

  /**
   * Update existing splits with pre-validated respondent data (optimized, unsafe version).
   * 
   * This method provides maximum performance by using a two-phase approach:
   * 
   * **Phase 1**: Update only fully-specified splits directly from respondent data
   * - Each respondent updates exactly one fully-specified split (O(1) per respondent)
   * - Skips all validation checks
   * - Skips checking aggregated splits
   * 
   * **Phase 2**: Aggregate statistics from fully-specified splits to partial splits
   * - Runs once after all respondents are processed
   * - Computes aggregated statistics by summing from fully-specified splits
   * 
   * **Performance**: For N respondents and S total splits with F fully-specified splits:
   * - This method: O(N × G + S × F) where G = number of grouping questions
   * - Standard approach: O(N × S × G)
   * - Typical speedup: 10-30x for large datasets
   * 
   * **WARNING**: This method assumes ALL inputs are valid and mutually compatible:
   * - `respondentsData` is already validated against `statsConfig`
   * - `existingSplits` match the structure defined by `statsConfig`
   * - `weightQuestion` (if provided) matches what was used to create `existingSplits`
   * - All respondents have answered all grouping questions with valid values
   * 
   * **No validation is performed**. Invalid data will produce incorrect statistics or errors.
   * 
   * Use this method for high-performance scenarios where you:
   * - Have pre-validated data from a trusted source
   * - Load splits from database, update with new data, save back
   * - Need to process thousands of respondents efficiently
   * 
   * @param existingSplits - Pre-existing splits to update (mutated in place)
   * @param statsConfig - Session configuration (must match the one used to create splits)
   * @param respondentsData - Pre-validated respondent data
   * @param weightQuestion - Optional weight question (must match existing splits)
   * @returns The mutated splits array (same reference as existingSplits)
   * 
   * @example
   * ```typescript
   * // Load splits from database
   * const splits = await loadSplitsFromDB(sessionId);
   * 
   * // Update with new pre-validated data
   * Statistics.updateSplitsUnsafe(
   *   splits,
   *   statsConfig,
   *   preValidatedRespondents,
   *   weightQuestion
   * );
   * 
   * // Save updated splits back to database
   * await saveSplitsToDB(sessionId, splits);
   * ```
   */
  static updateSplitsUnsafe(
    existingSplits: Split[],
    statsConfig: StatsConfig,
    respondentsData: RespondentData[],
    weightQuestion?: Question
  ): Split[] {
    // Phase 1: Update only fully-specified splits
    // A fully-specified split has no null response groups in its groups array
    const fullySpecifiedSplits = existingSplits.filter(split =>
      split.groups.every(g => g.responseGroup !== null)
    );

    // Create a lookup map for fast access to fully-specified splits
    // Key format: "varName:batteryName:subBattery:responseGroupLabel|..."
    const splitLookup = new Map<string, Split>();
    for (const split of fullySpecifiedSplits) {
      const key = split.groups
        .map(g => {
          const qKey = getQuestionKey(g.question);
          return `${qKey}:${g.responseGroup!.label}`;
        })
        .join('|');
      splitLookup.set(key, split);
    }

    // Process each respondent
    for (const respondentData of respondentsData) {
      const responseMap = createResponseMap(respondentData);

      // Determine weight
      let weight = 1;
      if (weightQuestion) {
        const weightResponse = responseMap.get(getQuestionKey(weightQuestion));
        if (weightResponse !== null && weightResponse !== undefined) {
          weight = weightResponse;
        }
      }

      // Find the fully-specified split this respondent belongs to
      // Build lookup key from respondent's grouping question answers
      const lookupKeyParts: string[] = [];
      for (const groupingQuestion of statsConfig.groupingQuestions) {
        const qKey = getQuestionKey(groupingQuestion);
        const answer = responseMap.get(qKey);

        // Find which response group this answer belongs to
        const responseGroup = groupingQuestion.responseGroups.find(rg =>
          rg.values.includes(answer as number)
        );

        if (responseGroup) {
          lookupKeyParts.push(`${qKey}:${responseGroup.label}`);
        }
      }

      const lookupKey = lookupKeyParts.join('|');
      const targetSplit = splitLookup.get(lookupKey);

      if (!targetSplit) {
        // This shouldn't happen with valid data, but skip if it does
        continue;
      }

      // Update response questions for this fully-specified split
      for (const responseQuestion of targetSplit.responseQuestions) {
        const questionKey = getQuestionKey(responseQuestion);
        const respondentAnswer = responseMap.get(questionKey);

        if (respondentAnswer === null || respondentAnswer === undefined) {
          continue;
        }

        // Check if answer is in any expanded group (for this response question)
        const isInExpandedGroup = responseQuestion.responseGroups.expanded.some(rg =>
          rg.values.includes(respondentAnswer)
        );

        if (!isInExpandedGroup) {
          continue;
        }

        // Update expanded groups
        for (const expandedGroup of responseQuestion.responseGroups.expanded) {
          if (expandedGroup.values.includes(respondentAnswer)) {
            expandedGroup.totalWeight += weight;
            expandedGroup.totalCount += 1;
          }
        }

        // Update collapsed groups
        for (const collapsedGroup of responseQuestion.responseGroups.collapsed) {
          if (collapsedGroup.values.includes(respondentAnswer)) {
            collapsedGroup.totalWeight += weight;
            collapsedGroup.totalCount += 1;
          }
        }

        // Update totals
        responseQuestion.totalWeight += weight;
        responseQuestion.totalCount += 1;
      }
    }

    // Phase 2: Aggregate from fully-specified splits to partial splits
    // Process all non-fully-specified splits
    for (const split of existingSplits) {
      // Skip fully-specified splits (already updated in Phase 1)
      const isFullySpecified = split.groups.every(g => g.responseGroup !== null);
      if (isFullySpecified) {
        // Recalculate proportions for fully-specified splits
        for (const responseQuestion of split.responseQuestions) {
          for (const expandedGroup of responseQuestion.responseGroups.expanded) {
            expandedGroup.proportion = responseQuestion.totalWeight > 0
              ? expandedGroup.totalWeight / responseQuestion.totalWeight
              : 0;
          }
          for (const collapsedGroup of responseQuestion.responseGroups.collapsed) {
            collapsedGroup.proportion = responseQuestion.totalWeight > 0
              ? collapsedGroup.totalWeight / responseQuestion.totalWeight
              : 0;
          }
        }
        continue;
      }

      // This is a partial split - aggregate from fully-specified splits
      // Find all fully-specified splits that match this partial split's filters
      const matchingFullySplits = fullySpecifiedSplits.filter(fullySplit => {
        // Check if fullySplit matches all non-null filters in the partial split
        for (let i = 0; i < split.groups.length; i++) {
          const partialGroup = split.groups[i];
          if (partialGroup.responseGroup === null) {
            // No filter for this grouping question - any value matches
            continue;
          }

          const fullyGroup = fullySplit.groups[i];
          // Check if the fully-specified split's response group matches
          if (fullyGroup.responseGroup!.label !== partialGroup.responseGroup.label) {
            return false;
          }
        }
        return true;
      });

      // Reset all statistics for this partial split
      for (const responseQuestion of split.responseQuestions) {
        responseQuestion.totalWeight = 0;
        responseQuestion.totalCount = 0;

        for (const expandedGroup of responseQuestion.responseGroups.expanded) {
          expandedGroup.totalWeight = 0;
          expandedGroup.totalCount = 0;
          expandedGroup.proportion = 0;
        }

        for (const collapsedGroup of responseQuestion.responseGroups.collapsed) {
          collapsedGroup.totalWeight = 0;
          collapsedGroup.totalCount = 0;
          collapsedGroup.proportion = 0;
        }
      }

      // Aggregate from matching fully-specified splits
      for (const matchingSplit of matchingFullySplits) {
        for (let rqIndex = 0; rqIndex < split.responseQuestions.length; rqIndex++) {
          const partialRQ = split.responseQuestions[rqIndex];
          const fullyRQ = matchingSplit.responseQuestions[rqIndex];

          partialRQ.totalWeight += fullyRQ.totalWeight;
          partialRQ.totalCount += fullyRQ.totalCount;

          // Aggregate expanded groups
          for (let rgIndex = 0; rgIndex < partialRQ.responseGroups.expanded.length; rgIndex++) {
            const partialRG = partialRQ.responseGroups.expanded[rgIndex];
            const fullyRG = fullyRQ.responseGroups.expanded[rgIndex];

            partialRG.totalWeight += fullyRG.totalWeight;
            partialRG.totalCount += fullyRG.totalCount;
          }

          // Aggregate collapsed groups
          for (let rgIndex = 0; rgIndex < partialRQ.responseGroups.collapsed.length; rgIndex++) {
            const partialRG = partialRQ.responseGroups.collapsed[rgIndex];
            const fullyRG = fullyRQ.responseGroups.collapsed[rgIndex];

            partialRG.totalWeight += fullyRG.totalWeight;
            partialRG.totalCount += fullyRG.totalCount;
          }
        }
      }

      // Recalculate proportions for this partial split
      for (const responseQuestion of split.responseQuestions) {
        for (const expandedGroup of responseQuestion.responseGroups.expanded) {
          expandedGroup.proportion = responseQuestion.totalWeight > 0
            ? expandedGroup.totalWeight / responseQuestion.totalWeight
            : 0;
        }
        for (const collapsedGroup of responseQuestion.responseGroups.collapsed) {
          collapsedGroup.proportion = responseQuestion.totalWeight > 0
            ? collapsedGroup.totalWeight / responseQuestion.totalWeight
            : 0;
        }
      }
    }

    return existingSplits;
  }

  /**
   * Generates all possible grouping combinations (splits) from the grouping questions.
   * and sets all proportions and totalWeights to 0.
   * 
   * To construct the splits: For each grouping question, we create combinations with:
   * - Each of its response groups (one at a time)
   * - null (representing "no filter" or "all respondents" for that question)
   * 
   * The result is a Cartesian product across all grouping questions.
   * 
   * Example: If we have 2 grouping questions:
   *   - Question A with response groups [RG1, RG2]
   *   - Question B with response groups [RG3, RG4]
   * 
   * We generate 9 splits:
   *   1. [A:RG1, B:RG3]  - Respondents in RG1 AND RG3
   *   2. [A:RG1, B:RG4]  - Respondents in RG1 AND RG4
   *   3. [A:RG1, B:null] - Respondents in RG1 (any value for B)
   *   4. [A:RG2, B:RG3]  - Respondents in RG2 AND RG3
   *   5. [A:RG2, B:RG4]  - Respondents in RG2 AND RG4
   *   6. [A:RG2, B:null] - Respondents in RG2 (any value for B)
   *   7. [A:null, B:RG3] - Respondents in RG3 (any value for A)
   *   8. [A:null, B:RG4] - Respondents in RG4 (any value for A)
   *   9. [A:null, B:null] - All respondents (no filters)
   * 
   * @param StatsConfig - Session configuration with grouping questions
   * @returns Array of Split objects with groups populated but responseQuestions empty (to be filled in Step 4)
   */
  private initializeSplits(statsConfig: StatsConfig): Split[] {
    // If there are no grouping questions, return a single split with no grouping filters
    if (statsConfig.groupingQuestions.length === 0) {
      return [
        {
          groups: [],
          responseQuestions: []
        },
      ];
    }

    // Build an array of options for each grouping question
    // Each option is either a ResponseGroup or null
    const optionsPerQuestion: (ResponseGroup | null)[][] = [];

    for (const groupingQuestion of statsConfig.groupingQuestions) {
      // For this question, create an array of all its response groups plus null
      const options: (ResponseGroup | null)[] = [
        ...groupingQuestion.responseGroups,
        null, // null means "don't filter by this question"
      ];
      optionsPerQuestion.push(options);
    }

    // Generate the Cartesian product of all options
    // Start with an array containing one empty combination
    let combinations: (ResponseGroup | null)[][] = [[]];

    // For each grouping question's options, expand the combinations
    for (const options of optionsPerQuestion) {
      const newCombinations: (ResponseGroup | null)[][] = [];

      // For each existing combination, create new combinations by appending each option
      for (const combination of combinations) {
        for (const option of options) {
          newCombinations.push([...combination, option]);
        }
      }

      combinations = newCombinations;
    }

    // Convert each combination into a Split object
    const splits: Split[] = [];

    for (const combination of combinations) {
      // Build the groups array for this split
      // Each element pairs a grouping question with its selected response group (or null)
      const groups: Split["groups"] = [];

      for (let i = 0; i < statsConfig.groupingQuestions.length; i++) {
        const question = statsConfig.groupingQuestions[i];
        const responseGroup = combination[i]; // Can be ResponseGroup or null

        groups.push({
          question: {
            varName: question.varName,
            batteryName: question.batteryName,
            subBattery: question.subBattery,
          },
          responseGroup: responseGroup,
        });
      }

      // Create the Split object
      // responseQuestions and totalWeight will be populated in Step 4 with computed proportions
      splits.push({
        groups: groups,
        responseQuestions: statsConfig.responseQuestions.map((responseQuestion) => ({
          varName: responseQuestion.varName,
          batteryName: responseQuestion.batteryName,
          subBattery: responseQuestion.subBattery,
          responseGroups: {
            expanded: responseQuestion.responseGroups.expanded.map((rg) => ({
              ...rg,
              proportion: 0,
              totalWeight: 0,
              totalCount: 0,
            })),
            collapsed: responseQuestion.responseGroups.collapsed.map((rg) => ({
              ...rg,
              proportion: 0,
              totalWeight: 0,
              totalCount: 0
            })),
          },
          totalWeight: 0,
          totalCount: 0
        })),
      });
    }

    return splits;
  }

  /**
   * Validates whether a respondent's data is valid for inclusion in statistics computation.
   * 
   * A respondent is considered valid if ALL of the following conditions are met:
   * 1. Has answered ALL grouping questions (i.e., there is a response in the responses array for each grouping question)
   * 2. If weightQuestion is defined, has answered the weightQuestion with a non-null value
   * 3. Has answered each grouping question with a response that is included in one of that grouping question's response groups (from StatsConfig)
   * 4. Has answered at least one of the response questions specified in the session config
   * 5. For at least one response question that the respondent answered, has given an answer that belongs to one of that response question's expanded response groups
   * 
   * @param responseMap - Map of question keys to response values for the respondent
   * @returns true if the respondent data is valid for computation, false otherwise
   */
  private validateRespondentData(responseMap: Map<string, number | null>): boolean {
    // Conditions 1 and 3: Check that ALL grouping questions have been answered AND
    // that each response is included in one of that question's response groups
    for (const groupingQuestion of this.statsConfig.groupingQuestions) {
      const key = getQuestionKey(groupingQuestion);

      // Condition 1: Check the question was answered
      if (!responseMap.has(key)) {
        return false; // Missing a grouping question response
      }

      const response = responseMap.get(key);

      // Condition 3: Check if this response value appears in any of the question's response groups
      // Note: If response is null/undefined, includes() will return false, so we don't need an explicit check
      const isInResponseGroup = groupingQuestion.responseGroups.some(rg =>
        rg.values.includes(response as number)
      );

      if (!isInResponseGroup) {
        return false; // Response not in any valid response group (or response was null/undefined)
      }
    }

    // Condition 2: If weightQuestion is defined, check that it has been answered with a non-null value
    if (this.weightQuestion) {
      const key = getQuestionKey(this.weightQuestion);
      const weightResponse = responseMap.get(key);
      if (!responseMap.has(key) || weightResponse === null || weightResponse === undefined) {
        return false; // Missing or invalid weight question response
      }
    }

    // Condition 4 & 5: Check that at least one response question has been answered
    // AND that at least one of those answers belongs to an expanded response group
    let hasValidResponseQuestion = false;

    for (const responseQuestion of this.statsConfig.responseQuestions) {
      const key = getQuestionKey(responseQuestion);
      const response = responseMap.get(key);

      // Skip if this response question wasn't answered
      if (response === null || response === undefined) {
        continue;
      }

      // Check if the response belongs to any expanded response group
      const isInExpandedGroup = responseQuestion.responseGroups.expanded.some(rg =>
        rg.values.includes(response)
      );

      if (isInExpandedGroup) {
        hasValidResponseQuestion = true;
        break; // We only need at least one valid response question
      }
    }

    if (!hasValidResponseQuestion) {
      return false; // No valid response questions answered
    }

    // All conditions met
    return true;
  }

  /**
   * Updates all splits with data from a single respondent.
   * 
   * Assumes the respondent data has already been validated using validateRespondentData().
   * 
   * Updates the statistics in the splits to which the respondent belongs.
   * The statistics updated in any given split are ONLY those for the response questions on which the
   * respondent gave an answer AND gave an answer that belongs to one of that response question's
   * response groups (defined in the session config).
   * 
   * This is the core building block for processing response data - it can be
   * called repeatedly for each response in a dataset.
   * 
   * @param responseMap - Map of question keys to response values for the respondent
   */
  private updateFromSingleRespondent(responseMap: Map<string, number | null>): void {
    // Step 1: Determine the respondent's weight
    // If weightQuestion is defined, use the respondent's answer; otherwise default to weight of 1
    let weight = 1;
    if (this.weightQuestion) {
      const weightResponse = responseMap.get(getQuestionKey(this.weightQuestion));
      // TypeScript doesn't know we've validated, so we need this check for type safety
      // In practice, weightResponse will always be a number here due to validation
      if (weightResponse !== null && weightResponse !== undefined) {
        weight = weightResponse;
      }
    }

    // Step 2: Iterate through all splits to determine which ones this respondent belongs to
    for (const split of this.splits) {
      // Step 2a: Check if respondent belongs to this split
      // A respondent belongs to a split if, for each grouping question:
      // - The split's responseGroup is null (meaning "all respondents"), OR
      // - The respondent's answer to that grouping question is in the split's responseGroup

      let belongsToSplit = true;

      for (const group of split.groups) {
        // If this split has no filter for this grouping question (null), respondent matches
        if (group.responseGroup === null) {
          continue; // Move to next grouping question
        }

        // Get the respondent's answer to this grouping question
        const respondentAnswer = responseMap.get(getQuestionKey(group.question));

        // Check if the respondent's answer is in this split's response group
        // The cast to number is safe because validation ensures grouping questions are answered with valid numbers
        if (!group.responseGroup.values.includes(respondentAnswer as number)) {
          belongsToSplit = false;
          break; // No need to check other grouping questions
        }
      }

      // Step 2b: If respondent doesn't belong to this split, skip to next split
      if (!belongsToSplit) {
        continue;
      }

      //if we reach this point, the respondent belongs to this split

      // Step 3: Update statistics for this split
      // For each response question in the split, check if respondent answered it
      // and if so, update the appropriate response group statistics

      for (const responseQuestion of split.responseQuestions) {
        // Get the respondent's answer to this response question
        const questionKey = getQuestionKey(responseQuestion);
        const respondentAnswer = responseMap.get(questionKey);

        // Skip if respondent didn't answer this question or answer is null
        if (respondentAnswer === null || respondentAnswer === undefined) {
          continue;
        }

        // Check if the answer belongs to at least one expanded response group
        // Validation only ensures SOME response question has a valid answer, not necessarily this one
        const isInExpandedGroup = responseQuestion.responseGroups.expanded.some(rg =>
          rg.values.includes(respondentAnswer)
        );

        // Skip this response question if the answer isn't in any expanded response group
        if (!isInExpandedGroup) {
          continue;
        }

        // Step 3a: Update expanded response groups
        for (const expandedGroup of responseQuestion.responseGroups.expanded) {
          if (expandedGroup.values.includes(respondentAnswer)) {
            expandedGroup.totalWeight += weight;
            expandedGroup.totalCount += 1;
          }
        }

        // Step 3b: Update collapsed response groups
        for (const collapsedGroup of responseQuestion.responseGroups.collapsed) {
          if (collapsedGroup.values.includes(respondentAnswer)) {
            collapsedGroup.totalWeight += weight;
            collapsedGroup.totalCount += 1;
          }
        }

        // Step 3c: Update the total weight and total count for this response question
        responseQuestion.totalWeight += weight;
        responseQuestion.totalCount += 1;

        // Sanity check: totalWeight should be positive after adding a validated respondent
        // If not, this indicates corrupted weight data (weight <= 0)
        if (responseQuestion.totalWeight <= 0) {
          throw new Error(
            `Invalid state: totalWeight is ${responseQuestion.totalWeight} after processing respondent. ` +
            `This indicates corrupted weight data (weight was ${weight}).`
          );
        }

        // Step 3d: Recalculate proportions for all response groups
        // Proportions are totalWeight / totalWeight for the question

        // Update expanded proportions
        for (const expandedGroup of responseQuestion.responseGroups.expanded) {
          expandedGroup.proportion = responseQuestion.totalWeight > 0
            ? expandedGroup.totalWeight / responseQuestion.totalWeight
            : 0;
        }

        // Update collapsed proportions
        for (const collapsedGroup of responseQuestion.responseGroups.collapsed) {
          collapsedGroup.proportion = responseQuestion.totalWeight > 0
            ? collapsedGroup.totalWeight / responseQuestion.totalWeight
            : 0;
        }
      }
    }
  }

  /**
   * Get the computed splits with statistics.
   * 
   * @returns Array of splits with computed statistics for response questions
   */
  public getSplits(): Split[] {
    return this.splits;
  }

  /**
   * Expose the session configuration used to construct this Statistics instance.
   * This is a read-only accessor intended for external validators and helpers.
   */
  public getStatsConfig(): StatsConfig {
    return this.statsConfig;
  }

  /**
   * Get the count of valid respondents that were successfully processed.
   * 
   * @returns Number of respondents who passed validation and were included in statistics
   */
  public getValidRespondentsCount(): number {
    return this.validRespondentsCount;
  }

  /**
   * Get the count of invalid respondents that were rejected during validation.
   * 
   * @returns Number of respondents who failed validation and were excluded from statistics
   */
  public getInvalidRespondentsCount(): number {
    return this.invalidRespondentsCount;
  }

  /**
   * Get the total count of respondents that were processed (valid + invalid).
   * 
   * @returns Total number of respondents attempted to process
   */
  public getTotalRespondentsProcessed(): number {
    return this.validRespondentsCount + this.invalidRespondentsCount;
  }

  /**
   * Subscribe to statistics updates.
   * 
   * The callback will be invoked whenever updateSplits() is called,
   * after the statistics have been updated. The callback receives
   * the full update result including deltas.
   * 
   * Multiple subscribers can be registered, and they will all be
   * notified in the order they subscribed.
   * 
   * @param callback - Function to call when statistics are updated
   * @returns Subscription object with unsubscribe method
   * 
   * @example
   * ```typescript
   * const stats = new Statistics(config);
   * const viz = new SegmentViz(stats, vizConfig);
   * 
   * // SegmentViz automatically subscribes in its constructor
   * // Or manually:
   * const subscription = stats.subscribe((updateResult) => {
   *   console.log(`Received ${updateResult.deltas.length} deltas`);
   *   // Update visualization
   * });
   * 
   * // Later, to stop receiving updates:
   * subscription.unsubscribe();
   * ```
   */
  public subscribe(callback: StatisticsSubscriber): StatisticsSubscription {
    this.subscribers.add(callback);
    const subscriberId = this.nextSubscriberId++;
    this.subscriberIds.set(callback, subscriberId);

    return {
      unsubscribe: () => {
        this.subscribers.delete(callback);
        this.subscriberIds.delete(callback);
      }
    };
  }

  /**
   * Notify all subscribers of an update.
   * Called internally after updateSplits processes new data.
   */
  private notifySubscribers(updateResult: StatisticsUpdateResult): void {
    // Create a copy of subscribers to avoid issues if a subscriber unsubscribes during notification
    const subscribersArray = Array.from(this.subscribers);

    for (const subscriber of subscribersArray) {
      try {
        subscriber(updateResult);
      } catch (error) {
        // Log error but continue notifying other subscribers
        console.error('Error in statistics subscriber:', error);
      }
    }
  }

  /**
   * Get the number of active subscribers.
   * Useful for debugging and monitoring.
   */
  public getSubscriberCount(): number {
    return this.subscribers.size;
  }

  /**
   * Update the splits with new respondent data.
   * 
   * This method allows incremental updates to statistics as new data arrives,
   * making it suitable for long-running processes that listen to live poll data
   * or other streaming response sources.
   * 
   * Returns deltas showing which response groups in which grouping combinations
   * had count increases, enabling efficient incremental visualization updates.
   * 
   * @param respondentsData - Array of new respondent data to process and add to statistics
   * @returns Update result with processing counts and deltas
   * @throws Error if weight data is corrupted (weight <= 0)
   * 
   * @example
   * ```typescript
   * const stats = new Statistics(StatsConfig);
   * // Later, as new data arrives...
   * const result = stats.updateSplits(newRespondents);
   * console.log(`Added ${result.validCount} new respondents`);
   * console.log(`Deltas: ${result.deltas.length} response groups changed`);
   * ```
   */
  public updateSplits(respondentsData: RespondentData[]): StatisticsUpdateResult {
    // Snapshot state before processing
    const beforeState = this.snapshotSplitStates();

    const validCountBefore = this.validRespondentsCount;
    const invalidCountBefore = this.invalidRespondentsCount;

    // Process each respondent's data
    for (const respondentData of respondentsData) {
      // Transform the respondent data into a map for efficient lookup
      const responseMap = createResponseMap(respondentData);

      // Validate that this respondent's data meets all requirements
      const isValid = this.validateRespondentData(responseMap);

      // Only update statistics if the respondent data is valid
      if (isValid) {
        this.updateFromSingleRespondent(responseMap);
        this.validRespondentsCount++;
      } else {
        // Track invalid respondents
        this.invalidRespondentsCount++;
      }
    }

    // Snapshot state after processing
    const afterState = this.snapshotSplitStates();

    // Compute deltas
    const deltas = this.computeDeltas(beforeState, afterState);

    const updateResult: StatisticsUpdateResult = {
      validCount: this.validRespondentsCount - validCountBefore,
      invalidCount: this.invalidRespondentsCount - invalidCountBefore,
      totalProcessed: respondentsData.length,
      deltas
    };

    // Notify all subscribers
    this.notifySubscribers(updateResult);

    return updateResult;
  }

  /**
   * Snapshot current state of all splits for delta computation.
   * Captures complete state: counts, weights, and proportions for all response groups.
   */
  private snapshotSplitStates(): Split[] {
    // Deep clone the current state of all splits
    return this.splits.map(split => ({
      groups: split.groups,
      responseQuestions: split.responseQuestions.map(rq => ({
        varName: rq.varName,
        batteryName: rq.batteryName,
        subBattery: rq.subBattery,
        totalWeight: rq.totalWeight,
        totalCount: rq.totalCount,
        responseGroups: {
          expanded: rq.responseGroups.expanded.map(rg => ({
            label: rg.label,
            values: rg.values,
            totalWeight: rg.totalWeight,
            totalCount: rg.totalCount,
            proportion: rg.proportion
          })),
          collapsed: rq.responseGroups.collapsed.map(rg => ({
            label: rg.label,
            values: rg.values,
            totalWeight: rg.totalWeight,
            totalCount: rg.totalCount,
            proportion: rg.proportion
          }))
        }
      }))
    }));
  }

  /**
   * Compute deltas by comparing before and after snapshots.
   * Returns an array of SplitDelta objects, one for each split that changed.
   */
  private computeDeltas(before: Split[], after: Split[]): SplitDelta[] {
    const deltas: SplitDelta[] = [];

    // Iterate through all splits by index
    for (let splitIndex = 0; splitIndex < this.splits.length; splitIndex++) {
      const beforeSplit = before[splitIndex];
      const afterSplit = after[splitIndex];
      const responseQuestionChanges: ResponseQuestionChange[] = [];

      // Check each response question for changes
      for (let rqIndex = 0; rqIndex < afterSplit.responseQuestions.length; rqIndex++) {
        const beforeRQ = beforeSplit.responseQuestions[rqIndex];
        const afterRQ = afterSplit.responseQuestions[rqIndex];

        // Check if this response question changed
        const rqChanged =
          beforeRQ.totalWeight !== afterRQ.totalWeight ||
          beforeRQ.totalCount !== afterRQ.totalCount;

        // Check expanded groups for changes
        const expandedGroupChanges: ResponseGroupChange[] = [];
        for (let rgIndex = 0; rgIndex < afterRQ.responseGroups.expanded.length; rgIndex++) {
          const beforeRG = beforeRQ.responseGroups.expanded[rgIndex];
          const afterRG = afterRQ.responseGroups.expanded[rgIndex];

          if (
            beforeRG.totalCount !== afterRG.totalCount ||
            beforeRG.totalWeight !== afterRG.totalWeight ||
            beforeRG.proportion !== afterRG.proportion
          ) {
            expandedGroupChanges.push({
              responseGroupLabel: afterRG.label,
              countBefore: beforeRG.totalCount,
              countAfter: afterRG.totalCount,
              weightBefore: beforeRG.totalWeight,
              weightAfter: afterRG.totalWeight,
              proportionBefore: beforeRG.proportion,
              proportionAfter: afterRG.proportion
            });
          }
        }

        // Check collapsed groups for changes
        const collapsedGroupChanges: ResponseGroupChange[] = [];
        for (let rgIndex = 0; rgIndex < afterRQ.responseGroups.collapsed.length; rgIndex++) {
          const beforeRG = beforeRQ.responseGroups.collapsed[rgIndex];
          const afterRG = afterRQ.responseGroups.collapsed[rgIndex];

          if (
            beforeRG.totalCount !== afterRG.totalCount ||
            beforeRG.totalWeight !== afterRG.totalWeight ||
            beforeRG.proportion !== afterRG.proportion
          ) {
            collapsedGroupChanges.push({
              responseGroupLabel: afterRG.label,
              countBefore: beforeRG.totalCount,
              countAfter: afterRG.totalCount,
              weightBefore: beforeRG.totalWeight,
              weightAfter: afterRG.totalWeight,
              proportionBefore: beforeRG.proportion,
              proportionAfter: afterRG.proportion
            });
          }
        }

        // If this response question had any changes, add it to the changes array
        if (rqChanged || expandedGroupChanges.length > 0 || collapsedGroupChanges.length > 0) {
          responseQuestionChanges.push({
            responseQuestionKey: getQuestionKey(afterRQ),
            totalWeightBefore: beforeRQ.totalWeight,
            totalWeightAfter: afterRQ.totalWeight,
            totalCountBefore: beforeRQ.totalCount,
            totalCountAfter: afterRQ.totalCount,
            expandedGroupChanges,
            collapsedGroupChanges
          });
        }
      }

      // If this split had any changes, add it to the deltas array
      if (responseQuestionChanges.length > 0) {
        deltas.push({
          splitIndex,
          responseQuestionChanges
        });
      }
    }

    return deltas;
  }

}
